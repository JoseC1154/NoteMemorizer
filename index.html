<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Key Drill — PWA</title>

<!--
GitHub Pages PWA notes:
- Rename this file to index.html and place it in your repo root.
- GitHub → Settings → Pages → Deploy from branch → main → /(root)
- Your URL will be: https://YOURNAME.github.io/REPO_NAME/
-->

<style>
  :root{
    --bg:#1e1e1e;
    --panel:#2a2a2a;
    --panel2:#232323;
    --text:#ffffff;
    --muted:#b9b9b9;
    --accent:#ffcc00;
    --good:#38d46a;
    --bad:#ff4b4b;
    --border:#444;
    --shadow: rgba(0,0,0,0.55);
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    background: radial-gradient(1200px 800px at 50% 0%, #2a2a2a 0%, var(--bg) 60%);
    color:var(--text);
    font-family: Arial, sans-serif;
    display:flex;
    min-height:100vh;
    align-items:center;
    justify-content:center;
    padding:16px;
    overflow-x:hidden;
    overflow-y:auto;
    -webkit-text-size-adjust: 100%;
  }

  .app{
    width: min(980px, calc(100vw - 32px));
    display:grid;
    grid-template-rows:auto auto auto 1fr auto;
    gap:14px;
    padding:16px;
    border:4px solid var(--border);
    border-radius:18px;
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
    box-shadow: 0 14px 35px var(--shadow);
    position:relative;
  }

  .topRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }

  .title{
    font-size: clamp(18px, 2.2vw, 26px);
    font-weight:800;
    letter-spacing:0.4px;
  }

  .pillRow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    justify-content:flex-end;
  }

  .pill{
    display:flex;
    align-items:center;
    gap:8px;
    padding:10px 12px;
    border:2px solid var(--border);
    border-radius:999px;
    background:#141414;
    font-size: clamp(12px, 1.6vw, 15px);
    color:var(--muted);
    user-select:none;
    max-width: 100%;
    white-space:normal;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .pill strong{ color:var(--text); font-weight:800; }

  .questionBox{
    border:3px solid var(--border);
    border-radius:14px;
    padding:14px 14px;
    background:#101010;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    position:relative;
    overflow:hidden;
  }

  .question{
    font-size: clamp(18px, 3.2vw, 34px);
    font-weight:900;
    letter-spacing:0.2px;
  }

  .timer{
    font-size: clamp(16px, 2.6vw, 30px);
    font-weight:900;
    color:var(--accent);
    min-width: 4ch;
    text-align:right;
  }

  .msg{
    margin-top:-6px;
    font-size: clamp(12px, 1.7vw, 15px);
    color: var(--muted);
    display:flex;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
  }

  /* Stair progress (simple line art) */
  .progressWrap{
    border:2px solid var(--border);
    border-radius:14px;
    background:#101010;
    padding:10px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .progressLeft{
    display:flex;
    align-items:center;
    gap:12px;
    min-width: 0;
  }
  .progressTitle{
    font-weight:900;
    color:var(--text);
    font-size:14px;
    white-space:nowrap;
  }
  .progressHint{
    font-size:12px;
    color:var(--muted);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .stairSvg{
    width: min(260px, 42vw);
    height: 90px;
    display:block;
  }
  /* Current step highlight */
  #stepHighlight{
    transition: d 180ms ease;
  }
  .stepPulse{
    animation: stepPulse 720ms ease-in-out infinite;
  }
  @keyframes stepPulse{
    0%{ opacity:0.55; }
    50%{ opacity:1; }
    100%{ opacity:0.55; }
  }

  .stairSvg .figureWrap{ }
  .stairSvg .figureInner{
    transition: transform 260ms ease;
    transform-origin: 0px 12px;
  }

  /* Constant walk cycle (jointed legs) */
  .stairSvg .figureInner{ transition: transform 260ms ease; transform-origin: 0px 12px; }

  /* Make SVG transforms behave consistently */
  .stairSvg g{ transform-box: fill-box; }

  .stairSvg .figureInner.running .thighL,
  .stairSvg .figureInner.running .thighR,
  .stairSvg .figureInner.running .shinL,
  .stairSvg .figureInner.running .shinR{
    transform-origin: 0px 0px;
  }

  /* Alternate leg swing */
  .stairSvg .figureInner.running .thighL{ animation: thighSwingL 520ms linear infinite; }
  .stairSvg .figureInner.running .shinL{ animation: shinSwingL 520ms linear infinite; }
  .stairSvg .figureInner.running .thighR{ animation: thighSwingR 520ms linear infinite; }
  .stairSvg .figureInner.running .shinR{ animation: shinSwingR 520ms linear infinite; }

  /* Subtle body bob */
  .stairSvg .figureInner.running{ animation: bodyBob 520ms linear infinite; }

  @keyframes thighSwingL{ 0%{ transform: rotate(18deg); } 50%{ transform: rotate(-18deg); } 100%{ transform: rotate(18deg);} }
  @keyframes shinSwingL{ 0%{ transform: rotate(-10deg); } 50%{ transform: rotate(22deg); } 100%{ transform: rotate(-10deg);} }
  @keyframes thighSwingR{ 0%{ transform: rotate(-18deg); } 50%{ transform: rotate(18deg); } 100%{ transform: rotate(-18deg);} }
  @keyframes shinSwingR{ 0%{ transform: rotate(22deg); } 50%{ transform: rotate(-10deg); } 100%{ transform: rotate(22deg);} }
  @keyframes bodyBob{ 0%{ transform: translateY(0); } 50%{ transform: translateY(-1.5px); } 100%{ transform: translateY(0);} }

  .stairSvg .figureWrap.tumble{
    animation: tumble 520ms ease;
    transform-origin: center;
  }
  @keyframes tumble{
    0%{ transform: rotate(0deg) translate(0,0); }
    30%{ transform: rotate(-85deg) translate(-6px,10px); }
    65%{ transform: rotate(35deg) translate(8px,14px); }
    100%{ transform: rotate(0deg) translate(0,0); }
  }

  .stairSvg.fallShake{
    animation: fallShake .35s ease;
  }
  @keyframes fallShake{
    0%{ transform: translateX(0); }
    25%{ transform: translateX(-4px); }
    50%{ transform: translateX(4px); }
    75%{ transform: translateX(-3px); }
    100%{ transform: translateX(0); }
  }

  .answers{ 
    display:grid;
    grid-template-columns: repeat(7, minmax(0, 1fr));
    gap:10px;
  }
  @media (max-width: 760px){
    .answers{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
  }
  @media (max-width: 420px){
    .answers{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
  }

  /* Mobile fit fixes */
  @media (max-width: 520px){
    body{ padding:10px; }
    .app{ padding:12px; gap:10px; border-width:3px; width: calc(100vw - 20px); }
    .pillRow{ justify-content:flex-start; }
    .pill{ padding:8px 10px; }
    .questionBox{ padding:12px; }
    .progressWrap{ padding:10px; }
    .progressLeft{ flex-wrap:wrap; }
    .stairSvg{ width: min(320px, 86vw); height: 86px; }

    .bottomRow{ flex-direction:column; align-items:stretch; }
    .controls{ width:100%; }
    .controls .btn{ flex:1 1 auto; }
    .status{ text-align:center; }
  }

  button.answer{
    border:3px solid var(--border);
    background:#0f0f0f;
    color:var(--text);
    border-radius:14px;
    padding:14px 10px;
    font-size: clamp(14px, 2.2vw, 20px);
    font-weight:900;
    cursor:pointer;
    transition: transform .08s ease, border-color .12s ease;
    box-shadow: 0 10px 20px rgba(0,0,0,.35);
    user-select:none;
  }
  button.answer:hover{
    transform: translateY(-2px);
    border-color:#666;
  }
  button.answer:active{
    transform: translateY(1px) scale(0.99);
  }
  button.answer:disabled{
    opacity:.7;
    cursor:not-allowed;
    transform:none;
  }

  .bottomRow{
    display:flex;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }

  .controls{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }

  .btn{
    padding:10px 12px;
    border-radius:12px;
    border:2px solid var(--border);
    background:#0f0f0f;
    color:var(--text);
    font-weight:900;
    cursor:pointer;
    font-size: 14px;
  }
  .btn:hover{ border-color:#666; }

  .btn.primary{
    border-color:#666;
    box-shadow: 0 10px 22px rgba(0,0,0,.35);
  }

  .status{
    font-size:14px;
    color:var(--muted);
  }

  /* overlays */
  .overlayFX{
    position:absolute;
    inset:0;
    pointer-events:none;
    opacity:0;
    transition: opacity .12s ease;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .overlayFX.show{ opacity:1; }

  /* End modal (clickable) */
  .overlayModal{
    position:absolute;
    inset:0;
    opacity:0;
    pointer-events:none;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.55);
    transition: opacity .15s ease;
  }
  .overlayModal.show{
    opacity:1;
    pointer-events:auto;
  }
  .modalCard{
    width:min(560px, 92%);
    border:3px solid var(--border);
    border-radius:18px;
    background: #121212;
    box-shadow: 0 18px 40px rgba(0,0,0,.65);
    padding:18px 16px;
  }
  .modalTitle{
    font-size: clamp(20px, 3vw, 30px);
    font-weight:1000;
    margin-bottom:6px;
  }
  .modalBody{
    color: var(--muted);
    font-size: 14px;
    margin-bottom:10px;
  }
  .modalStats{
    border:2px solid var(--border);
    border-radius:14px;
    padding:10px 12px;
    background:#0f0f0f;
    color:#fff;
    font-weight:900;
    display:flex;
    gap:14px;
    flex-wrap:wrap;
    margin-bottom:12px;
  }
  .modalBtns{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }

  .fxCard{
    width:min(520px, 92%);
    padding:18px 16px;
    border-radius:16px;
    border:3px solid var(--border);
    background:#121212;
    box-shadow: 0 18px 40px rgba(0,0,0,.55);
    display:flex;
    align-items:center;
    gap:14px;
  }

  /* Wrong: red ghost */
  .fxCard.bad{
    border-color:#5b1b1b;
    background: radial-gradient(600px 220px at 50% 0%, rgba(255,75,75,.25), rgba(0,0,0,.15) 60%), #1a0f0f;
  }
  .ghost{
    width:64px; height:64px;
    border-radius:18px;
    background: linear-gradient(180deg, #ff4b4b, #b31313);
    position:relative;
    box-shadow: inset 0 -8px 0 rgba(0,0,0,.15);
  }
  .ghost:before{
    content:"";
    position:absolute;
    left:10px; top:16px;
    width:14px; height:14px;
    background:#fff;
    border-radius:50%;
    box-shadow: 30px 0 0 #fff;
  }
  .ghost:after{
    content:"";
    position:absolute;
    left:14px; top:20px;
    width:6px; height:6px;
    background:#000;
    border-radius:50%;
    box-shadow: 30px 0 0 #000;
  }

  /* Correct: green face */
  .fxCard.good{
    border-color:#1f5b2f;
    background: radial-gradient(600px 220px at 50% 0%, rgba(56,212,106,.25), rgba(0,0,0,.15) 60%), #0f1a12;
  }
  .face{
    width:64px; height:64px;
    border-radius:18px;
    background: linear-gradient(180deg, #38d46a, #1b8e3d);
    position:relative;
    box-shadow: inset 0 -8px 0 rgba(0,0,0,.15);
  }
  .face:before{
    content:"";
    position:absolute;
    left:12px; top:18px;
    width:12px; height:12px;
    background:#fff;
    border-radius:50%;
    box-shadow: 28px 0 0 #fff;
  }
  .face:after{
    content:"";
    position:absolute;
    left:18px; top:40px;
    width:28px; height:14px;
    border-bottom:6px solid rgba(0,0,0,.55);
    border-radius:0 0 999px 999px;
  }

  .fxText{
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .fxText .big{
    font-size: clamp(18px, 2.5vw, 26px);
    font-weight:1000;
  }
  .fxText .small{
    font-size: 14px;
    opacity:.9;
  }

  /* Wrong shake */
  .shake{ animation: shake .28s ease; }
  @keyframes shake{
    0%{ transform: translateX(0); }
    25%{ transform: translateX(-8px); }
    50%{ transform: translateX(8px); }
    75%{ transform: translateX(-6px); }
    100%{ transform: translateX(0); }
  }

  .timeLow{
    color: #ff8f1f !important;
    text-shadow: 0 0 12px rgba(255,143,31,.25);
  }
  .timeOut{
    color: var(--bad) !important;
    text-shadow: 0 0 14px rgba(255,75,75,.25);
  }
</style>
</head>

<body>
<div class="app" id="app">
  <div class="topRow">
    <div class="title">Key Drill</div>
    <div class="pillRow">
      <div class="pill">Mode: <strong id="modeLabel">Major</strong></div>
      <div class="pill">Streak: <strong id="streakLabel">0</strong></div>
      <div class="pill">Score: <strong id="scoreLabel">0</strong></div>
      <div class="pill">Steps: <strong id="stepsLabel">0</strong></div>
      <div class="pill">Tries: <strong id="triesLabel">3</strong></div>
      <div class="pill">Q#: <strong id="qLabel">1</strong></div>
    </div>
  </div>

  <div class="questionBox" id="questionBox">
    <div class="question" id="questionText">Press Start</div>
    <div class="timer" id="timerText">--</div>
  </div>

  <div class="msg">
    <div id="subText">Answer by clicking one of the 7 notes.</div>
    <div id="hintText">Accidentals shown as ♭ / ♯</div>
  </div>

  <div class="progressWrap" aria-label="Stair progress">
    <div class="progressLeft">
      <svg class="stairSvg" id="stairSvg" viewBox="0 0 220 120" role="img" aria-label="Stairs with stick figure">
        <defs>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2.2" result="blur" />
            <feMerge>
              <feMergeNode in="blur" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <path id="stairsPath" d="" fill="none" stroke="#ffffff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" opacity="0.9"></path>
        <path id="stepHighlight" d="" fill="none" stroke="#ffcc00" stroke-width="6" stroke-linecap="round" opacity="0.95" filter="url(#glow)"></path>
        <g class="figureWrap" id="figureWrap" transform="translate(0,0)">
          <g class="figureInner" id="figure" fill="none" stroke="#ffffff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
            <!-- Jointed stick figure (line art) drawn around (0,0) -->
            <!-- Head -->
            <circle cx="0" cy="-12" r="6"></circle>
            <!-- Neck/Body -->
            <line x1="0" y1="-6" x2="0" y2="18"></line>
            <!-- Arms -->
            <g id="armL" transform="translate(0,2)">
              <line x1="0" y1="0" x2="-12" y2="6"></line>
              <circle cx="-12" cy="6" r="2"></circle>
            </g>
            <g id="armR" transform="translate(0,2)">
              <line x1="0" y1="0" x2="12" y2="6"></line>
              <circle cx="12" cy="6" r="2"></circle>
            </g>
            <!-- Hip joint -->
            <circle cx="0" cy="18" r="2"></circle>

            <!-- Left leg: hip -> knee -> ankle (nested groups so CSS rotation looks natural) -->
            <g id="legL" transform="translate(0,18)">
              <g class="thighL">
                <line x1="0" y1="0" x2="-6" y2="12"></line>
                <circle class="knee" cx="-6" cy="12" r="2"></circle>
                <g class="shinL" transform="translate(-6,12)">
                  <line x1="0" y1="0" x2="-4" y2="14"></line>
                  <circle class="ankle" cx="-4" cy="14" r="2"></circle>
                </g>
              </g>
            </g>

            <!-- Right leg -->
            <g id="legR" transform="translate(0,18)">
              <g class="thighR">
                <line x1="0" y1="0" x2="6" y2="12"></line>
                <circle class="knee" cx="6" cy="12" r="2"></circle>
                <g class="shinR" transform="translate(6,12)">
                  <line x1="0" y1="0" x2="4" y2="14"></line>
                  <circle class="ankle" cx="4" cy="14" r="2"></circle>
                </g>
              </g>
            </g>
          </g>
        </g>
      </svg>
      <div>
        <div class="progressTitle">Stair Climb</div>
        <div class="progressHint">Correct = up 1 step • Wrong/Time = down 2 steps</div>
      </div>
    </div>
  </div>

  <div class="answers" id="answers"></div>

  <div class="bottomRow">
    <div class="controls">
      <button class="btn primary" id="startBtn">Start</button>
      <button class="btn" id="skipBtn">Skip</button>
      <button class="btn" id="modeBtn">Toggle Major/Minor</button>
      <button class="btn" id="resetBtn">Reset</button>
      <button class="btn" id="installBtn" style="display:none;">Install</button>
    </div>
    <div class="status" id="statusText">Ready.</div>
  </div>

  <!-- BAD overlay -->
  <div class="overlayFX" id="overlayBad" aria-hidden="true">
    <div class="fxCard bad">
      <div class="ghost"></div>
      <div class="fxText">
        <div class="big" id="fxBadBig">Wrong!</div>
        <div class="small" id="fxBadSmall">Try the next one…</div>
      </div>
    </div>
  </div>

  <!-- GOOD overlay -->
  <div class="overlayFX" id="overlayGood" aria-hidden="true">
    <div class="fxCard good">
      <div class="face"></div>
      <div class="fxText">
        <div class="big" id="fxGoodBig">Correct!</div>
        <div class="small" id="fxGoodSmall">Nice — keep going…</div>
      </div>
    </div>
  </div>

  <!-- GAME OVER / WIN modal -->
  <div class="overlayModal" id="overlayEnd" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="endTitle">
      <div class="modalTitle" id="endTitle">Game Over</div>
      <div class="modalBody" id="endBody">You fell down the stairs.</div>
      <div class="modalStats" id="endStats"></div>
      <div class="modalBtns">
        <button class="btn primary" id="restartBtn">Restart</button>
        <button class="btn" id="closeEndBtn">Close</button>
      </div>
    </div>
  </div>
</div>

<script>
/*************************************************
 * PWA-in-one-file (GitHub Pages friendly)
 * - Generates icons + manifest at runtime
 * - Registers a blob service worker with scope "./"
 *************************************************/
(async function setupPWA(){
  const isSecure = (location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1");
  if(!isSecure) return;

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function makeIcon(size){
    const c = document.createElement("canvas");
    c.width = c.height = size;
    const ctx = c.getContext("2d");

    const g = ctx.createLinearGradient(0,0,size,size);
    g.addColorStop(0, "#2a2a2a");
    g.addColorStop(1, "#121212");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,size,size);

    ctx.strokeStyle = "#444";
    ctx.lineWidth = Math.max(8, size * 0.03);
    ctx.strokeRect(ctx.lineWidth/2, ctx.lineWidth/2, size-ctx.lineWidth, size-ctx.lineWidth);

    const pad = size * 0.18;
    const w = size - pad*2;
    const r = w * 0.18;

    const gg = ctx.createLinearGradient(0,pad,0,pad+w);
    gg.addColorStop(0, "rgba(56,212,106,1)");
    gg.addColorStop(1, "rgba(27,142,61,1)");
    ctx.fillStyle = gg;
    roundRect(ctx, pad, pad, w, w, r);
    ctx.fill();

    ctx.fillStyle = "#fff";
    const eyeR = w * 0.09;
    ctx.beginPath(); ctx.arc(pad + w*0.32, pad + w*0.38, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pad + w*0.68, pad + w*0.38, eyeR, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = "rgba(0,0,0,.55)";
    ctx.lineWidth = Math.max(6, w*0.06);
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.arc(pad + w*0.5, pad + w*0.58, w*0.22, 0, Math.PI, false);
    ctx.stroke();

    ctx.fillStyle = "#ffcc00";
    ctx.font = `900 ${Math.floor(size*0.18)}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("KD", size/2, size*0.79);

    return c.toDataURL("image/png");
  }

  const icon192 = makeIcon(192);
  const icon512 = makeIcon(512);

  // GitHub Pages-friendly: start_url/scope should be "./" for project pages
  const manifest = {
    name: "Key Drill",
    short_name: "KeyDrill",
    start_url: "./",
    scope: "./",
    display: "standalone",
    background_color: "#1e1e1e",
    theme_color: "#1e1e1e",
    icons: [
      { src: icon192, sizes: "192x192", type: "image/png" },
      { src: icon512, sizes: "512x512", type: "image/png" }
    ]
  };

  const manifestBlob = new Blob([JSON.stringify(manifest)], { type: "application/manifest+json" });
  const manifestURL = URL.createObjectURL(manifestBlob);

  let link = document.querySelector('link[rel="manifest"]');
  if(!link){
    link = document.createElement("link");
    link.rel = "manifest";
    document.head.appendChild(link);
  }
  link.href = manifestURL;

  let appleIcon = document.querySelector('link[rel="apple-touch-icon"]');
  if(!appleIcon){
    appleIcon = document.createElement("link");
    appleIcon.rel = "apple-touch-icon";
    document.head.appendChild(appleIcon);
  }
  appleIcon.href = icon512;

  if("serviceWorker" in navigator){
    const swCode = `
      const CACHE = "keydrill-onefile-v2";
      const PRECACHE = ["./", "./index.html"];

      self.addEventListener("install", (event) => {
        event.waitUntil((async () => {
          const cache = await caches.open(CACHE);
          try { await cache.addAll(PRECACHE); } catch(e) {}
          self.skipWaiting();
        })());
      });

      self.addEventListener("activate", (event) => {
        event.waitUntil((async () => {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => (k !== CACHE) ? caches.delete(k) : null));
          self.clients.claim();
        })());
      });

      self.addEventListener("fetch", (event) => {
        const req = event.request;
        event.respondWith((async () => {
          const cache = await caches.open(CACHE);
          const cached = await cache.match(req, { ignoreSearch: true });
          if(cached) return cached;

          try{
            const fresh = await fetch(req);
            if(req.method === "GET" && new URL(req.url).origin === location.origin){
              cache.put(req, fresh.clone());
            }
            return fresh;
          }catch(e){
            // Offline fallback to app shell
            const fallback = await cache.match("./", { ignoreSearch: true }) || await cache.match("./index.html", { ignoreSearch: true });
            return fallback || new Response("Offline", { status: 200, headers: { "Content-Type": "text/plain" } });
          }
        })());
      });
    `;

    const swBlob = new Blob([swCode], { type: "text/javascript" });
    const swURL = URL.createObjectURL(swBlob);

    try{
      await navigator.serviceWorker.register(swURL, { scope: "./" });
    }catch(e){
      // App still runs normally.
    }
  }
})();

/*************************************************
 * Game logic
 *************************************************/
const ANSWER_PAUSE_MS = 2000;

const questionBox = document.getElementById("questionBox");
const questionText = document.getElementById("questionText");
const timerText = document.getElementById("timerText");
const answersEl = document.getElementById("answers");
const statusText = document.getElementById("statusText");

const modeLabel = document.getElementById("modeLabel");
const streakLabel = document.getElementById("streakLabel");
const scoreLabel  = document.getElementById("scoreLabel");
const qLabel      = document.getElementById("qLabel");
const stepsLabel  = document.getElementById("stepsLabel");
const triesLabel  = document.getElementById("triesLabel");

const overlayBad = document.getElementById("overlayBad");
const overlayGood = document.getElementById("overlayGood");
const fxBadBig = document.getElementById("fxBadBig");
const fxBadSmall = document.getElementById("fxBadSmall");
const fxGoodBig = document.getElementById("fxGoodBig");
const fxGoodSmall = document.getElementById("fxGoodSmall");

const overlayEnd = document.getElementById("overlayEnd");
const endTitle = document.getElementById("endTitle");
const endBody = document.getElementById("endBody");
const endStats = document.getElementById("endStats");
const restartBtn = document.getElementById("restartBtn");
const closeEndBtn = document.getElementById("closeEndBtn");

const startBtn = document.getElementById("startBtn");
const skipBtn  = document.getElementById("skipBtn");
const modeBtn  = document.getElementById("modeBtn");
const resetBtn = document.getElementById("resetBtn");
const installBtn = document.getElementById("installBtn");

const SHARPS = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const FLAT_TO_SHARP = {"Db":"C#","Eb":"D#","Gb":"F#","Ab":"G#","Bb":"A#"};

function toSharp(note){ return FLAT_TO_SHARP[note] || note; }
function pcIndex(note){ return SHARPS.indexOf(toSharp(note)); }
function fromPcIndex(i){ return SHARPS[((i%12)+12)%12]; }
function pretty(note){ return note.replace("b","♭").replace("#","♯"); }

const MAJOR_STEPS = [0,2,4,5,7,9,11];
const NAT_MINOR_STEPS = [0,2,3,5,7,8,10];

const DEGREE_BANK_MAJOR = ["1","2","3","4","5","6","7","b2","b3","b6","b7","#4","#5"];
const DEGREE_BANK_MINOR = ["1","2","b3","4","5","b6","b7","b2","3","6","7","#4","#5"];

const KEY_BANK = ["C","G","D","A","E","B","F#","F","Bb","Eb","Ab","Db"];

const MAX_STEPS = 12;
const STEP_UP = 1;
const STEP_DOWN = 2;

let state = {
  running:false,
  locked:false,
  mode:"Major",
  score:0,
  streak:0,
  qNum:1,
  secondsPerQ: 10,
  timeLeft: 10,
  timerId:null,
  current:null,
  climb: 0,
  firstTriesLeft: 3
};

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function degreeToSemitones(degStr, mode){
  const accidental = degStr.startsWith("b") ? -1 : degStr.startsWith("#") ? +1 : 0;
  const num = parseInt(degStr.replace(/[b#]/g,""), 10);
  const steps = (mode==="Major") ? MAJOR_STEPS : NAT_MINOR_STEPS;
  const base = steps[num-1];
  return base + accidental;
}

function buildQuestion(){
  const key = pick(KEY_BANK);
  const bank = (state.mode==="Major") ? DEGREE_BANK_MAJOR : DEGREE_BANK_MINOR;
  const degree = pick(bank);

  const rootPc = pcIndex(key);
  const semis = degreeToSemitones(degree, state.mode);
  const answerNote = fromPcIndex(rootPc + semis);

  return { key, degree, answerNote };
}

function buildOptions(correct){
  const others = SHARPS.filter(n => n !== correct);
  const chosen = shuffle(others).slice(0,6);
  return shuffle([correct, ...chosen]);
}

function setQuestionUI(q){
  const degPretty = q.degree.replace("b","♭").replace("#","♯");
  questionText.textContent = `What is the ${degPretty} in the key of ${q.key} ${state.mode}?`;
  qLabel.textContent = String(state.qNum);
}

function renderAnswers(options){
  answersEl.innerHTML = "";
  options.forEach(note => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = pretty(note);
    btn.addEventListener("click", () => onAnswer(note));
    answersEl.appendChild(btn);
  });
}

function setButtonsEnabled(enabled){
  answersEl.querySelectorAll("button.answer").forEach(b => b.disabled = !enabled);
}

function updateHUD(){
  modeLabel.textContent = state.mode;
  streakLabel.textContent = String(state.streak);
  scoreLabel.textContent = String(state.score);
  stepsLabel.textContent = String(state.climb);
  triesLabel.textContent = (state.qNum === 1) ? String(state.firstTriesLeft) : "—";
}

function stopTimer(){
  if(state.timerId){
    clearInterval(state.timerId);
    state.timerId = null;
  }
}

function paintTimer(){
  timerText.textContent = String(state.timeLeft).padStart(2,"0");
  timerText.classList.remove("timeLow","timeOut");
  if(state.timeLeft <= 3 && state.timeLeft > 0) timerText.classList.add("timeLow");
  if(state.timeLeft <= 0) timerText.classList.add("timeOut");
}

/*************************************************
 * AUDIO (Web Audio API) — single-file, no assets
 *************************************************/
let audioCtx;
function getAudioCtx(){
  if(!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  return audioCtx;
}
function beep({freq=440, duration=0.12, type="sine", gain=0.12}){
  const ctx = getAudioCtx();
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(ctx.destination);
  o.start();
  o.stop(ctx.currentTime + duration);
}
function soundCorrect(){
  beep({freq:880, duration:0.09, gain:0.14});
  setTimeout(() => beep({freq:1175, duration:0.12, gain:0.14}), 90);
}
function soundWrong(){
  beep({freq:220, duration:0.18, type:"square", gain:0.12});
}
function soundTick(){
  beep({freq:1000, duration:0.03, type:"square", gain:0.05});
}

/*************************************************
 * STAIR PROGRESS (SVG line art)
 *************************************************/
const stairSvg = document.getElementById("stairSvg");
const stairsPath = document.getElementById("stairsPath");
const stepHighlight = document.getElementById("stepHighlight");
const figureWrap = document.getElementById("figureWrap");
const figure = document.getElementById("figure");

function initStairs(){
  // Stair geometry
  const startX = 26;
  const startY = 98;
  const stepW = 14;
  const stepH = 7;
  const platformLen = 18;

  // Option 1: flat step platforms (disconnected segments)
  // Draw each step as a short horizontal line, plus a small riser at the far right.
  let d = "";
  for(let i=0;i<=MAX_STEPS;i++){
    const x0 = startX + stepW * i;
    const y  = startY - stepH * i;
    const x1 = x0 + platformLen;
    d += `M ${x0} ${y} L ${x1} ${y} `;
    d += `M ${x1} ${y} L ${x1} ${y - stepH} `;
  }
  stairsPath.setAttribute("d", d.trim());

  // Store for positioning
  stairSvg.dataset.startX = String(startX);
  stairSvg.dataset.startY = String(startY);
  stairSvg.dataset.stepW = String(stepW);
  stairSvg.dataset.stepH = String(stepH);
  stairSvg.dataset.platformLen = String(platformLen);

  renderFigure();
}

function clamp(n, min, max){
  return Math.max(min, Math.min(max, n));
}

function updateStepHighlight(){
  const startX = Number(stairSvg.dataset.startX || 26);
  const startY = Number(stairSvg.dataset.startY || 98);
  const stepW = Number(stairSvg.dataset.stepW || 14);
  const stepH = Number(stairSvg.dataset.stepH || 7);
  const platformLen = Number(stairSvg.dataset.platformLen || 18);

  const i = clamp(state.climb, 0, MAX_STEPS);
  const x0 = startX + stepW * i;
  const y  = startY - stepH * i;
  const x1 = x0 + platformLen;

  stepHighlight.setAttribute("d", `M ${x0} ${y} L ${x1} ${y}`);
  stepHighlight.classList.add("stepPulse");
}

function renderFigure(){
  const startX = Number(stairSvg.dataset.startX || 30);
  const startY = Number(stairSvg.dataset.startY || 98);
  const stepW = Number(stairSvg.dataset.stepW || 14);
  const stepH = Number(stairSvg.dataset.stepH || 7);

  // position the figure at the center of the current step
  const i = clamp(state.climb, 0, MAX_STEPS);
  const platformLen = Number(stairSvg.dataset.platformLen || 18);

  // Center the figure over the current platform segment
  const x0 = startX + stepW * i;
  const x = x0 + platformLen * 0.5;

  // Lift the figure so it stands above the platform
  const y = startY - stepH * i - 28;
  figureWrap.setAttribute("transform", `translate(${x},${y})`);
  updateStepHighlight();
}

function setRunner(active){
  figure.classList.toggle("running", !!active);
}

function doFallFX(){
  stairSvg.classList.remove("fallShake");
  void stairSvg.offsetWidth;
  stairSvg.classList.add("fallShake");
  figureWrap.classList.remove("tumble");
  void figureWrap.getBBox();
  figureWrap.classList.add("tumble");
}

function moveClimb(delta, {shake=false, suppressEnd=false} = {}){
  const before = state.climb;
  state.climb = clamp(state.climb + delta, 0, MAX_STEPS);
  if(state.climb !== before){
    renderFigure();
    updateHUD();
  }

  // End conditions
  if(!suppressEnd){
    if(delta > 0 && state.climb >= MAX_STEPS){
      endGame({ title: "You Win!", body: "You made it to the top of the stairs.", variant: "win" });
      return;
    }
    if(delta < 0 && state.climb === 0){
      endGame({ title: "Game Over", body: "You fell to the bottom of the stairs.", variant: "lose" });
      return;
    }
  }
  if(shake){
    doFallFX();
  }
}

function resetClimb(){
  state.climb = 0;
  renderFigure();
}

function startTimer(){
  stopTimer();
  state.timeLeft = state.secondsPerQ;
  paintTimer();
  state.timerId = setInterval(() => {
    state.timeLeft -= 1;
    soundTick();
    paintTimer();
    if(state.timeLeft <= 0) timeUp();
  }, 1000);
}

function _old_startTimer(){
  stopTimer();
  state.timeLeft = state.secondsPerQ;
  paintTimer();
  state.timerId = setInterval(() => {
    state.timeLeft -= 1;
    paintTimer();
    if(state.timeLeft <= 0) timeUp();
  }, 1000);
}

function hideOverlays(){
  overlayBad.classList.remove("show");
  overlayGood.classList.remove("show");
}

function showBad(title, subtitle){
  fxBadBig.textContent = title || "Wrong!";
  fxBadSmall.textContent = subtitle || "Try the next one…";
  overlayBad.classList.add("show");
  questionBox.classList.add("shake");
  setTimeout(() => questionBox.classList.remove("shake"), 300);
}

function showGood(title, subtitle){
  fxGoodBig.textContent = title || "Correct!";
  fxGoodSmall.textContent = subtitle || "Nice — keep going…";
  overlayGood.classList.add("show");
}

function lockForFeedback(){
  state.locked = true;
  setButtonsEnabled(false);
  stopTimer();
}

function unlockAfterFeedback(){
  state.locked = false;
  hideOverlays();
  setButtonsEnabled(true);
}

function replayCurrentQuestion(){
  if(!state.running) return;
  hideOverlays();
  setQuestionUI(state.current);
  renderAnswers(buildOptions(state.current.answerNote));
  setButtonsEnabled(true);
  startTimer();
  statusText.textContent = "Try again!";
}

function nextQuestion(){
  if(!state.running) return;
  hideOverlays();
  state.current = buildQuestion();
  setQuestionUI(state.current);
  renderAnswers(buildOptions(state.current.answerNote));
  setButtonsEnabled(true);
  startTimer();
  statusText.textContent = "Pick the correct note.";
}

function onAnswer(note){
  if(!state.running || state.locked) return;

  const correct = state.current.answerNote;
  lockForFeedback();

  if(note === correct){
    const bonus = 10 + Math.min(10, state.streak);
    state.score += bonus;
    state.streak += 1;
    updateHUD();

    statusText.textContent = `✅ Correct: ${pretty(correct)} (+${bonus})`;
    showGood("Correct!", `Yes — ${pretty(correct)}.`);
    soundCorrect();

    // Stair climb: up 1 step
    moveClimb(STEP_UP);
  } else {
    state.score = Math.max(0, state.score - 4);
    state.streak = 0;
    updateHUD();
    statusText.textContent = `❌ Wrong: you picked ${pretty(note)}.`;
    showBad("Wrong!", `Correct was ${pretty(correct)}.`);
    soundWrong();
    // First-question grace: 3 tries while still on the ground floor
    if(state.qNum === 1 && state.climb === 0){
      state.firstTriesLeft = Math.max(0, state.firstTriesLeft - 1);
      updateHUD();

      if(state.firstTriesLeft <= 0){
        // No tries left → game over
        doFallFX();
        endGame({ title: "Game Over", body: "Out of tries on Question 1.", variant: "lose" });
        return;
      }

      // Feedback + fall FX, then retry SAME question (do not advance qNum)
      doFallFX();
      statusText.textContent = `❌ Wrong — Try again (Q1). Tries left: ${state.firstTriesLeft}`;
      showBad("Try again!", `Tries left for Question 1: ${state.firstTriesLeft}`);

      setTimeout(() => {
        unlockAfterFeedback();
        replayCurrentQuestion();
      }, ANSWER_PAUSE_MS);

      return;
    }

    // Stair fall: down 2 steps
    moveClimb(-STEP_DOWN, { shake:true });
  }

  state.qNum += 1;

  setTimeout(() => {
    unlockAfterFeedback();
    nextQuestion();
  }, ANSWER_PAUSE_MS);
}

function timeUp(){
  if(!state.running || state.locked) return;

  const correct = state.current?.answerNote || "";
  lockForFeedback();

  state.score = Math.max(0, state.score - 2);
  state.streak = 0;
  updateHUD();
  paintTimer();

  statusText.textContent = "⏱️ Time up!";
  soundWrong();

  // Stair fall: down 2 steps
  // First-question grace: 3 tries while still on the ground floor
  if(state.qNum === 1 && state.climb === 0){
    state.firstTriesLeft = Math.max(0, state.firstTriesLeft - 1);
    updateHUD();

    if(state.firstTriesLeft <= 0){
      doFallFX();
      endGame({ title: "Game Over", body: "Out of tries on Question 1 (time ran out).", variant: "lose" });
      return;
    }

    doFallFX();
    showBad("Try again!", `Time up — Tries left for Question 1: ${state.firstTriesLeft}`);

    setTimeout(() => {
      unlockAfterFeedback();
      replayCurrentQuestion();
    }, ANSWER_PAUSE_MS);

    return;
  }

  // If already at bottom after Q1, game over
  if(state.climb === 0){
    endGame({ title: "Game Over", body: "Time ran out at the bottom of the stairs.", variant: "lose" });
    return;
  }

  moveClimb(-STEP_DOWN, { shake:true });

  showBad("Time!",  correct ? `Correct was ${pretty(correct)}.` : "Try the next one…");

  state.qNum += 1;

  setTimeout(() => {
    unlockAfterFeedback();
    nextQuestion();
  }, ANSWER_PAUSE_MS);
}

function startGame(){
  if(state.running) return;
  state.running = true;
  state.locked = false;
  state.qNum = 1;
  state.score = 0;
  state.streak = 0;
  state.current = null;
  state.climb = 0;
  state.firstTriesLeft = 3;
  hideEnd();
  setRunner(true);
  renderFigure();
  updateHUD();
  statusText.textContent = "Game started.";
  nextQuestion();
}

function resetGame(){
  stopTimer();
  hideOverlays();
  hideEnd();
  state.running = false;
  state.locked = false;
  state.score = 0;
  state.streak = 0;
  state.qNum = 1;
  state.current = null;
  state.firstTriesLeft = 3;
  resetClimb();
  setRunner(false);
  updateHUD();

  questionText.textContent = "Press Start";
  timerText.textContent = "--";
  answersEl.innerHTML = "";
  statusText.textContent = "Ready.";
}

function skipQuestion(){
  if(!state.running || state.locked) return;

  lockForFeedback();
  statusText.textContent = "↪️ Skipped.";
  showBad("Skipped", "No penalty this time.");
  state.qNum += 1;

  setTimeout(() => {
    unlockAfterFeedback();
    nextQuestion();
  }, ANSWER_PAUSE_MS);
}

function toggleMode(){
  state.mode = (state.mode === "Major") ? "Minor" : "Major";
  updateHUD();
  statusText.textContent = `Mode set to ${state.mode}.`;
  if(state.running && !state.locked){
    stopTimer();
    nextQuestion();
  }
}

restartBtn.addEventListener("click", () => {
  resetGame();
  startGame();
});
closeEndBtn.addEventListener("click", () => {
  hideEnd();
});

startBtn.addEventListener("click", startGame);
resetBtn.addEventListener("click", resetGame);
skipBtn.addEventListener("click", skipQuestion);
modeBtn.addEventListener("click", toggleMode);

// Keyboard shortcuts
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  if(e.key === "Enter") startGame();
  if(k === "r") resetGame();
  if(k === "m") toggleMode();
  if(k === "s") skipQuestion();
});

/*************************************************
 * Install button (Chrome/Edge on GitHub Pages)
 *************************************************/
let deferredPrompt = null;
window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = "inline-block";
  statusText.textContent = "Install available (click Install).";
});

installBtn.addEventListener("click", async () => {
  if(!deferredPrompt) return;
  deferredPrompt.prompt();
  await deferredPrompt.userChoice;
  deferredPrompt = null;
  installBtn.style.display = "none";
  statusText.textContent = "Installed (or install dismissed).";
});

function showEnd(){
  overlayEnd.classList.add("show");
  overlayEnd.setAttribute("aria-hidden", "false");
}
function hideEnd(){
  overlayEnd.classList.remove("show");
  overlayEnd.setAttribute("aria-hidden", "true");
}
function endGame({title="Game Over", body="", variant="lose"} = {}){
  stopTimer();
  hideOverlays();
  state.running = false;
  state.locked = true;
  setButtonsEnabled(false);
  setRunner(false);

  endTitle.textContent = title;
  endBody.textContent = body;
  endStats.textContent = `Score: ${state.score} • Streak: ${state.streak} • Steps: ${state.climb} • Q#: ${state.qNum}`;

  endTitle.style.color = (variant === "win") ? "var(--good)" : "var(--bad)";
  statusText.textContent = title;
  showEnd();
}

updateHUD();
initStairs();
setRunner(false);
</script>
</body>
</html>
