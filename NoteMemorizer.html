<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Key Drill — PWA</title>

<!--
PWA note:
- Install/offline needs HTTPS or localhost.
- Quick local server:
  Python 3:  python -m http.server 5173
  Then open: http://localhost:5173/key-drill-pwa.html
-->

<style>
  :root{
    --bg:#1e1e1e;
    --panel:#2a2a2a;
    --panel2:#232323;
    --text:#ffffff;
    --muted:#b9b9b9;
    --accent:#ffcc00;
    --good:#38d46a;
    --bad:#ff4b4b;
    --border:#444;
    --shadow: rgba(0,0,0,0.55);
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    background: radial-gradient(1200px 800px at 50% 0%, #2a2a2a 0%, var(--bg) 60%);
    color:var(--text);
    font-family: Arial, sans-serif;
    display:flex;
    min-height:100vh;
    align-items:center;
    justify-content:center;
    padding:16px;
    overflow:hidden;
  }

  .app{
    width:min(980px, 98vw);
    display:grid;
    grid-template-rows:auto auto auto 1fr auto;
    gap:14px;
    padding:16px;
    border:4px solid var(--border);
    border-radius:18px;
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
    box-shadow: 0 14px 35px var(--shadow);
    position:relative;
  }

  .topRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }

  .title{
    font-size: clamp(18px, 2.2vw, 26px);
    font-weight:800;
    letter-spacing:0.4px;
  }

  .pillRow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    justify-content:flex-end;
  }

  .pill{
    display:flex;
    align-items:center;
    gap:8px;
    padding:10px 12px;
    border:2px solid var(--border);
    border-radius:999px;
    background:#141414;
    font-size: clamp(12px, 1.6vw, 15px);
    color:var(--muted);
    user-select:none;
    white-space:nowrap;
  }
  .pill strong{ color:var(--text); font-weight:800; }

  .questionBox{
    border:3px solid var(--border);
    border-radius:14px;
    padding:14px 14px;
    background:#101010;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    position:relative;
    overflow:hidden;
  }

  .question{
    font-size: clamp(18px, 3.2vw, 34px);
    font-weight:900;
    letter-spacing:0.2px;
  }

  .timer{
    font-size: clamp(16px, 2.6vw, 30px);
    font-weight:900;
    color:var(--accent);
    min-width: 4ch;
    text-align:right;
  }

  .msg{
    margin-top:-6px;
    font-size: clamp(12px, 1.7vw, 15px);
    color: var(--muted);
    display:flex;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
  }

  .answers{
    display:grid;
    grid-template-columns: repeat(7, minmax(0, 1fr));
    gap:10px;
  }
  @media (max-width: 760px){
    .answers{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
  }
  @media (max-width: 420px){
    .answers{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
  }

  button.answer{
    border:3px solid var(--border);
    background:#0f0f0f;
    color:var(--text);
    border-radius:14px;
    padding:14px 10px;
    font-size: clamp(14px, 2.2vw, 20px);
    font-weight:900;
    cursor:pointer;
    transition: transform .08s ease, border-color .12s ease;
    box-shadow: 0 10px 20px rgba(0,0,0,.35);
    user-select:none;
  }
  button.answer:hover{
    transform: translateY(-2px);
    border-color:#666;
  }
  button.answer:active{
    transform: translateY(1px) scale(0.99);
  }
  button.answer:disabled{
    opacity:.7;
    cursor:not-allowed;
    transform:none;
  }

  .bottomRow{
    display:flex;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }

  .controls{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }

  .btn{
    padding:10px 12px;
    border-radius:12px;
    border:2px solid var(--border);
    background:#0f0f0f;
    color:var(--text);
    font-weight:900;
    cursor:pointer;
    font-size: 14px;
  }
  .btn:hover{ border-color:#666; }

  .btn.primary{
    border-color:#666;
    box-shadow: 0 10px 22px rgba(0,0,0,.35);
  }

  .status{
    font-size:14px;
    color:var(--muted);
  }

  /* overlays */
  .overlayFX{
    position:absolute;
    inset:0;
    pointer-events:none;
    opacity:0;
    transition: opacity .12s ease;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .overlayFX.show{ opacity:1; }

  .fxCard{
    width:min(520px, 92%);
    padding:18px 16px;
    border-radius:16px;
    border:3px solid var(--border);
    background:#121212;
    box-shadow: 0 18px 40px rgba(0,0,0,.55);
    display:flex;
    align-items:center;
    gap:14px;
  }

  /* Wrong: red ghost */
  .fxCard.bad{
    border-color:#5b1b1b;
    background: radial-gradient(600px 220px at 50% 0%, rgba(255,75,75,.25), rgba(0,0,0,.15) 60%), #1a0f0f;
  }
  .ghost{
    width:64px; height:64px;
    border-radius:18px;
    background: linear-gradient(180deg, #ff4b4b, #b31313);
    position:relative;
    box-shadow: inset 0 -8px 0 rgba(0,0,0,.15);
  }
  .ghost:before{
    content:"";
    position:absolute;
    left:10px; top:16px;
    width:14px; height:14px;
    background:#fff;
    border-radius:50%;
    box-shadow: 30px 0 0 #fff;
  }
  .ghost:after{
    content:"";
    position:absolute;
    left:14px; top:20px;
    width:6px; height:6px;
    background:#000;
    border-radius:50%;
    box-shadow: 30px 0 0 #000;
  }

  /* Correct: green face */
  .fxCard.good{
    border-color:#1f5b2f;
    background: radial-gradient(600px 220px at 50% 0%, rgba(56,212,106,.25), rgba(0,0,0,.15) 60%), #0f1a12;
  }
  .face{
    width:64px; height:64px;
    border-radius:18px;
    background: linear-gradient(180deg, #38d46a, #1b8e3d);
    position:relative;
    box-shadow: inset 0 -8px 0 rgba(0,0,0,.15);
  }
  .face:before{
    content:"";
    position:absolute;
    left:12px; top:18px;
    width:12px; height:12px;
    background:#fff;
    border-radius:50%;
    box-shadow: 28px 0 0 #fff;
  }
  .face:after{
    content:"";
    position:absolute;
    left:18px; top:40px;
    width:28px; height:14px;
    border-bottom:6px solid rgba(0,0,0,.55);
    border-radius:0 0 999px 999px;
  }

  .fxText{
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .fxText .big{
    font-size: clamp(18px, 2.5vw, 26px);
    font-weight:1000;
  }
  .fxText .small{
    font-size: 14px;
    opacity:.9;
  }

  /* Wrong shake */
  .shake{ animation: shake .28s ease; }
  @keyframes shake{
    0%{ transform: translateX(0); }
    25%{ transform: translateX(-8px); }
    50%{ transform: translateX(8px); }
    75%{ transform: translateX(-6px); }
    100%{ transform: translateX(0); }
  }

  .timeLow{
    color: #ff8f1f !important;
    text-shadow: 0 0 12px rgba(255,143,31,.25);
  }
  .timeOut{
    color: var(--bad) !important;
    text-shadow: 0 0 14px rgba(255,75,75,.25);
  }
</style>
</head>

<body>
<div class="app" id="app">
  <div class="topRow">
    <div class="title">Key Drill</div>
    <div class="pillRow">
      <div class="pill">Mode: <strong id="modeLabel">Major</strong></div>
      <div class="pill">Streak: <strong id="streakLabel">0</strong></div>
      <div class="pill">Score: <strong id="scoreLabel">0</strong></div>
      <div class="pill">Q#: <strong id="qLabel">1</strong></div>
    </div>
  </div>

  <div class="questionBox" id="questionBox">
    <div class="question" id="questionText">Press Start</div>
    <div class="timer" id="timerText">--</div>
  </div>

  <div class="msg">
    <div id="subText">Answer by clicking one of the 7 notes.</div>
    <div id="hintText">Accidentals shown as ♭ / ♯</div>
  </div>

  <div class="answers" id="answers"></div>

  <div class="bottomRow">
    <div class="controls">
      <button class="btn primary" id="startBtn">Start</button>
      <button class="btn" id="skipBtn">Skip</button>
      <button class="btn" id="modeBtn">Toggle Major/Minor</button>
      <button class="btn" id="resetBtn">Reset</button>
      <button class="btn" id="installBtn" style="display:none;">Install</button>
    </div>
    <div class="status" id="statusText">Ready.</div>
  </div>

  <!-- BAD overlay -->
  <div class="overlayFX" id="overlayBad" aria-hidden="true">
    <div class="fxCard bad">
      <div class="ghost"></div>
      <div class="fxText">
        <div class="big" id="fxBadBig">Wrong!</div>
        <div class="small" id="fxBadSmall">Try the next one…</div>
      </div>
    </div>
  </div>

  <!-- GOOD overlay -->
  <div class="overlayFX" id="overlayGood" aria-hidden="true">
    <div class="fxCard good">
      <div class="face"></div>
      <div class="fxText">
        <div class="big" id="fxGoodBig">Correct!</div>
        <div class="small" id="fxGoodSmall">Nice — keep going…</div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   PWA-in-one-file setup
   - Creates manifest + icons as blob URLs
   - Registers service worker from blob
   ========================= */

(async function setupPWA(){
  // Some browsers won’t allow PWA features on file://
  const isSecure = (location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1");
  if(!isSecure){
    // Still runs as a normal app.
    return;
  }

  // Create simple icons (192 + 512) as PNG data URLs using canvas
  function makeIcon(size){
    const c = document.createElement("canvas");
    c.width = c.height = size;
    const ctx = c.getContext("2d");

    // background
    const g = ctx.createLinearGradient(0,0,size,size);
    g.addColorStop(0, "#2a2a2a");
    g.addColorStop(1, "#121212");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,size,size);

    // border
    ctx.strokeStyle = "#444";
    ctx.lineWidth = Math.max(8, size * 0.03);
    ctx.strokeRect(ctx.lineWidth/2, ctx.lineWidth/2, size-ctx.lineWidth, size-ctx.lineWidth);

    // green face
    const pad = size * 0.18;
    const w = size - pad*2;
    const r = w * 0.18;
    ctx.fillStyle = "#1b8e3d";
    roundRect(ctx, pad, pad, w, w, r);
    ctx.fill();

    // top highlight
    const gg = ctx.createLinearGradient(0,pad,0,pad+w);
    gg.addColorStop(0, "rgba(56,212,106,1)");
    gg.addColorStop(1, "rgba(27,142,61,1)");
    ctx.fillStyle = gg;
    roundRect(ctx, pad, pad, w, w, r);
    ctx.fill();

    // eyes
    ctx.fillStyle = "#fff";
    const eyeR = w * 0.09;
    ctx.beginPath(); ctx.arc(pad + w*0.32, pad + w*0.38, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pad + w*0.68, pad + w*0.38, eyeR, 0, Math.PI*2); ctx.fill();

    // smile
    ctx.strokeStyle = "rgba(0,0,0,.55)";
    ctx.lineWidth = Math.max(6, w*0.06);
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.arc(pad + w*0.5, pad + w*0.58, w*0.22, 0, Math.PI, false);
    ctx.stroke();

    // "KD" label
    ctx.fillStyle = "#ffcc00";
    ctx.font = `900 ${Math.floor(size*0.18)}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("KD", size/2, size*0.79);

    return c.toDataURL("image/png");
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  const icon192 = makeIcon(192);
  const icon512 = makeIcon(512);

  // Create manifest blob URL
  const manifest = {
    name: "Key Drill",
    short_name: "KeyDrill",
    start_url: "./" + (location.pathname.split("/").pop() || ""),
    display: "standalone",
    background_color: "#1e1e1e",
    theme_color: "#1e1e1e",
    icons: [
      { src: icon192, sizes: "192x192", type: "image/png" },
      { src: icon512, sizes: "512x512", type: "image/png" }
    ]
  };

  const manifestBlob = new Blob([JSON.stringify(manifest)], { type: "application/manifest+json" });
  const manifestURL = URL.createObjectURL(manifestBlob);

  let link = document.querySelector('link[rel="manifest"]');
  if(!link){
    link = document.createElement("link");
    link.rel = "manifest";
    document.head.appendChild(link);
  }
  link.href = manifestURL;

  // iOS home screen icon
  let appleIcon = document.querySelector('link[rel="apple-touch-icon"]');
  if(!appleIcon){
    appleIcon = document.createElement("link");
    appleIcon.rel = "apple-touch-icon";
    document.head.appendChild(appleIcon);
  }
  appleIcon.href = icon512;

  // Register a service worker from a Blob (still single-file)
  if("serviceWorker" in navigator){
    const swCode = `
      const CACHE = "keydrill-onefile-v1";
      self.addEventListener("install", (event) => {
        event.waitUntil((async () => {
          const cache = await caches.open(CACHE);
          // Cache the app shell (this page)
          try { await cache.addAll([self.registration.scope]); } catch(e) {}
          self.skipWaiting();
        })());
      });
      self.addEventListener("activate", (event) => {
        event.waitUntil((async () => {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => (k !== CACHE) ? caches.delete(k) : null));
          self.clients.claim();
        })());
      });
      self.addEventListener("fetch", (event) => {
        const req = event.request;
        event.respondWith((async () => {
          const cache = await caches.open(CACHE);
          const cached = await cache.match(req, { ignoreSearch: true });
          if(cached) return cached;
          try{
            const fresh = await fetch(req);
            // Cache same-origin GETs
            if(req.method === "GET" && new URL(req.url).origin === location.origin){
              cache.put(req, fresh.clone());
            }
            return fresh;
          }catch(e){
            // Offline fallback: app shell
            const fallback = await cache.match(self.registration.scope, { ignoreSearch: true });
            return fallback || new Response("Offline", { status: 200, headers: { "Content-Type": "text/plain" } });
          }
        })());
      });
    `;
    const swBlob = new Blob([swCode], { type: "text/javascript" });
    const swURL = URL.createObjectURL(swBlob);
    try{
      await navigator.serviceWorker.register(swURL, { scope: "./" });
    }catch(e){
      // If it fails, app still runs normally.
    }
  }
})();

/* =========================
   App logic (game)
   ========================= */

const ANSWER_PAUSE_MS = 2000;

const questionBox = document.getElementById("questionBox");
const questionText = document.getElementById("questionText");
const timerText = document.getElementById("timerText");
const answersEl = document.getElementById("answers");
const statusText = document.getElementById("statusText");

const modeLabel = document.getElementById("modeLabel");
const streakLabel = document.getElementById("streakLabel");
const scoreLabel  = document.getElementById("scoreLabel");
const qLabel      = document.getElementById("qLabel");

const overlayBad = document.getElementById("overlayBad");
const overlayGood = document.getElementById("overlayGood");
const fxBadBig = document.getElementById("fxBadBig");
const fxBadSmall = document.getElementById("fxBadSmall");
const fxGoodBig = document.getElementById("fxGoodBig");
const fxGoodSmall = document.getElementById("fxGoodSmall");

const startBtn = document.getElementById("startBtn");
const skipBtn  = document.getElementById("skipBtn");
const modeBtn  = document.getElementById("modeBtn");
const resetBtn = document.getElementById("resetBtn");
const installBtn = document.getElementById("installBtn");

const SHARPS = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const FLAT_TO_SHARP = {"Db":"C#","Eb":"D#","Gb":"F#","Ab":"G#","Bb":"A#"};

function toSharp(note){ return FLAT_TO_SHARP[note] || note; }
function pcIndex(note){ return SHARPS.indexOf(toSharp(note)); }
function fromPcIndex(i){ return SHARPS[((i%12)+12)%12]; }
function pretty(note){ return note.replace("b","♭").replace("#","♯"); }

const MAJOR_STEPS = [0,2,4,5,7,9,11];
const NAT_MINOR_STEPS = [0,2,3,5,7,8,10];

const DEGREE_BANK_MAJOR = ["1","2","3","4","5","6","7","b2","b3","b6","b7","#4","#5"];
const DEGREE_BANK_MINOR = ["1","2","b3","4","5","b6","b7","b2","3","6","7","#4","#5"];

const KEY_BANK = ["C","G","D","A","E","B","F#","F","Bb","Eb","Ab","Db"];

let state = {
  running:false,
  locked:false,
  mode:"Major",
  score:0,
  streak:0,
  qNum:1,
  secondsPerQ: 10,
  timeLeft: 10,
  timerId:null,
  current:null
};

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function degreeToSemitones(degStr, mode){
  const accidental = degStr.startsWith("b") ? -1 : degStr.startsWith("#") ? +1 : 0;
  const num = parseInt(degStr.replace(/[b#]/g,""), 10);
  const steps = (mode==="Major") ? MAJOR_STEPS : NAT_MINOR_STEPS;
  const base = steps[num-1];
  return base + accidental;
}

function buildQuestion(){
  const key = pick(KEY_BANK);
  const bank = (state.mode==="Major") ? DEGREE_BANK_MAJOR : DEGREE_BANK_MINOR;
  const degree = pick(bank);

  const rootPc = pcIndex(key);
  const semis = degreeToSemitones(degree, state.mode);
  const answerNote = fromPcIndex(rootPc + semis);

  return { key, degree, answerNote };
}

function buildOptions(correct){
  const others = SHARPS.filter(n => n !== correct);
  const chosen = shuffle(others).slice(0,6);
  return shuffle([correct, ...chosen]);
}

function setQuestionUI(q){
  const degPretty = q.degree.replace("b","♭").replace("#","♯");
  questionText.textContent = `What is the ${degPretty} in the key of ${q.key} ${state.mode}?`;
  qLabel.textContent = String(state.qNum);
}

function renderAnswers(options){
  answersEl.innerHTML = "";
  options.forEach(note => {
    const btn = document.createElement("button");
    btn.className = "answer";
    btn.textContent = pretty(note);
    btn.addEventListener("click", () => onAnswer(note));
    answersEl.appendChild(btn);
  });
}

function setButtonsEnabled(enabled){
  answersEl.querySelectorAll("button.answer").forEach(b => b.disabled = !enabled);
}

function updateHUD(){
  modeLabel.textContent = state.mode;
  streakLabel.textContent = String(state.streak);
  scoreLabel.textContent = String(state.score);
}

function stopTimer(){
  if(state.timerId){
    clearInterval(state.timerId);
    state.timerId = null;
  }
}

function paintTimer(){
  timerText.textContent = String(state.timeLeft).padStart(2,"0");
  timerText.classList.remove("timeLow","timeOut");
  if(state.timeLeft <= 3 && state.timeLeft > 0) timerText.classList.add("timeLow");
  if(state.timeLeft <= 0) timerText.classList.add("timeOut");
}

function startTimer(){
  stopTimer();
  state.timeLeft = state.secondsPerQ;
  paintTimer();
  state.timerId = setInterval(() => {
    state.timeLeft -= 1;
    paintTimer();
    if(state.timeLeft <= 0) timeUp();
  }, 1000);
}

function hideOverlays(){
  overlayBad.classList.remove("show");
  overlayGood.classList.remove("show");
}

function showBad(title, subtitle){
  fxBadBig.textContent = title || "Wrong!";
  fxBadSmall.textContent = subtitle || "Try the next one…";
  overlayBad.classList.add("show");
  questionBox.classList.add("shake");
  setTimeout(() => questionBox.classList.remove("shake"), 300);
}

function showGood(title, subtitle){
  fxGoodBig.textContent = title || "Correct!";
  fxGoodSmall.textContent = subtitle || "Nice — keep going…";
  overlayGood.classList.add("show");
}

function lockForFeedback(){
  state.locked = true;
  setButtonsEnabled(false);
  stopTimer();
}

function unlockAfterFeedback(){
  state.locked = false;
  hideOverlays();
  setButtonsEnabled(true);
}

function nextQuestion(){
  if(!state.running) return;
  hideOverlays();
  state.current = buildQuestion();
  setQuestionUI(state.current);
  renderAnswers(buildOptions(state.current.answerNote));
  setButtonsEnabled(true);
  startTimer();
  statusText.textContent = "Pick the correct note.";
}

function onAnswer(note){
  if(!state.running || state.locked) return;

  const correct = state.current.answerNote;
  lockForFeedback();

  if(note === correct){
    const bonus = 10 + Math.min(10, state.streak);
    state.score += bonus;
    state.streak += 1;
    updateHUD();
    statusText.textContent = `✅ Correct: ${pretty(correct)} (+${bonus})`;
    showGood("Correct!", `Yes — ${pretty(correct)}.`);
  } else {
    state.score = Math.max(0, state.score - 4);
    state.streak = 0;
    updateHUD();
    statusText.textContent = `❌ Wrong: you picked ${pretty(note)}.`;
    showBad("Wrong!", `Correct was ${pretty(correct)}.`);
  }

  state.qNum += 1;

  setTimeout(() => {
    unlockAfterFeedback();
    nextQuestion();
  }, ANSWER_PAUSE_MS);
}

function timeUp(){
  if(!state.running || state.locked) return;

  const correct = state.current?.answerNote || "";
  lockForFeedback();

  state.score = Math.max(0, state.score - 2);
  state.streak = 0;
  updateHUD();
  paintTimer();

  statusText.textContent = "⏱️ Time up!";
  showBad("Time!", correct ? `Correct was ${pretty(correct)}.` : "Try the next one…");

  state.qNum += 1;

  setTimeout(() => {
    unlockAfterFeedback();
    nextQuestion();
  }, ANSWER_PAUSE_MS);
}

function startGame(){
  if(state.running) return;
  state.running = true;
  state.locked = false;
  state.qNum = 1;
  state.score = 0;
  state.streak = 0;
  updateHUD();
  statusText.textContent = "Game started.";
  nextQuestion();
}

function resetGame(){
  stopTimer();
  hideOverlays();
  state.running = false;
  state.locked = false;
  state.score = 0;
  state.streak = 0;
  state.qNum = 1;
  state.current = null;
  updateHUD();

  questionText.textContent = "Press Start";
  timerText.textContent = "--";
  answersEl.innerHTML = "";
  statusText.textContent = "Ready.";
}

function skipQuestion(){
  if(!state.running || state.locked) return;

  lockForFeedback();
  statusText.textContent = "↪️ Skipped.";
  showBad("Skipped", "No penalty this time.");
  state.qNum += 1;

  setTimeout(() => {
    unlockAfterFeedback();
    nextQuestion();
  }, ANSWER_PAUSE_MS);
}

function toggleMode(){
  state.mode = (state.mode === "Major") ? "Minor" : "Major";
  updateHUD();
  statusText.textContent = `Mode set to ${state.mode}.`;
  if(state.running && !state.locked){
    stopTimer();
    nextQuestion();
  }
}

startBtn.addEventListener("click", startGame);
resetBtn.addEventListener("click", resetGame);
skipBtn.addEventListener("click", skipQuestion);
modeBtn.addEventListener("click", toggleMode);

// Keyboard shortcuts
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  if(e.key === "Enter") startGame();
  if(k === "r") resetGame();
  if(k === "m") toggleMode();
  if(k === "s") skipQuestion();
});

/* Install prompt button */
let deferredPrompt = null;
window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = "inline-block";
  statusText.textContent = "Install available (click Install).";
});

installBtn.addEventListener("click", async () => {
  if(!deferredPrompt) return;
  deferredPrompt.prompt();
  await deferredPrompt.userChoice;
  deferredPrompt = null;
  installBtn.style.display = "none";
  statusText.textContent = "Installed (or install dismissed).";
});

updateHUD();
</script>
</body>
</html>
